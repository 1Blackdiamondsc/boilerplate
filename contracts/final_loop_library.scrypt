// Library

import "final_loop_import.scrypt";

library Util {
	//First just the util.scrypt file
    static const int DataLen = 1;
    static const int OutputValueLen = 8;
    // convert signed integer `n` to unsigned integer of `l` bytes, in little endian
	static function toLEUnsigned(int n, int l): bytes {
		// one extra byte to accommodate possible negative sign byte
		bytes m = num2bin(n, l + 1);
		// remove sign byte
		return m[0 : len(m) - 1];
	}
    // convert bytes to unsigned integer, in sign-magnitude little endian
    static function fromLEUnsigned(bytes b): int {
		// append positive sign byte. This does not hurt even when sign bit is already positive
		return unpack(b + b'00');
	}
    static function readVarint(bytes b): bytes {
		int l = 0;
		bytes ret = b'';
		bytes header = b[0:1];

		if (header == b'fd') {
			l = this.fromLEUnsigned(b[1:3]);
			ret = b[3:3+l];
		} else if (header == b'fe') {
			l = this.fromLEUnsigned(b[1:5]);
			ret = b[5:5+l];
		} else if (header == b'ff') {
			l = this.fromLEUnsigned(b[1:9]);
			ret = b[9:9+l];
		} else {
			l = this.fromLEUnsigned(b[0:1]);
			ret = b[1:1+l];
		}

		return ret;
	}
	// convert 'b' to a VarInt field, including the preceding length
    static function writeVarint(bytes b): bytes {
		int n = len(b);

		bytes header = b'';

		if (n < 0xfd) {
			header = this.toLEUnsigned(n, 1);
		} else if (n < 0x10000) {
			header = b'fd' + this.toLEUnsigned(n, 2);
		} else if (n < 0x100000000) {
			header = b'fe' + this.toLEUnsigned(n, 4);
		} else if (n < 0x10000000000000000) {
			header = b'ff' + this.toLEUnsigned(n, 8);
		}

		return header + b;
	}
	// build a tx output from its script and satoshi amount
	static function buildOutput(SigHashPreimage preimage, bytes outputScript, int outputSatoshis): bytes {
		//We reset in_loop
		bytes scriptCode = Util.scriptCode(preimage);
		bytes next = num2bin(0, 1) + scriptCode[len(scriptCode)-Aux.SizeOfObject:];
		return num2bin(outputSatoshis, Util.OutputValueLen) + this.writeVarint(outputScript + next);
	}
	// build a tx output from its script and satoshi amount
	static function buildOutputRaw(bytes outputScript, int outputSatoshis): bytes {
		return num2bin(outputSatoshis, Util.OutputValueLen) + this.writeVarint(outputScript);
	}
	// scriptCode is just scriptPubKey if there is no CODESEPARATOR in the latter
	static function scriptCode(SigHashPreimage preimage): bytes {
		return this.readVarint(preimage[104:len(preimage)-Aux.SizeOfObject-1]);
	}
	static function scriptCodeRaw(SigHashPreimage preimage): bytes {
		return this.readVarint(preimage[104:]);
	}
	static function hashOutputs(SigHashPreimage preimage): bytes {
		int l = len(preimage);
		return preimage[l - 40 : l - 8];
	}
    static function valueRaw(SigHashPreimage preimage): bytes {
		int l = len(preimage);
		return preimage[l - 52 : l - 44];
	}
    static function value(SigHashPreimage preimage): int {
		return this.fromLEUnsigned(this.valueRaw(preimage));
	}
	///////////////////////////////////////////////////////////
	// Interesting part below
	///////////////////////////////////////////////////////////
	//Get state
	static function getState(SigHashPreimage preimage): Object {
        bytes scriptCode = this.scriptCodeRaw(preimage);
		int scriptLen = len(scriptCode);
		return Aux.bytes_to_object(scriptCode[scriptLen-1-2*Aux.SizeOfObject:scriptLen-1-Aux.SizeOfObject]);
	}
	static function getInLoop(SigHashPreimage preimage): int {
        bytes scriptCode = this.scriptCodeRaw(preimage);
		int scriptLen = len(scriptCode);
		return unpack(scriptCode[scriptLen-1-Aux.SizeOfObject:scriptLen-Aux.SizeOfObject]);
	}
	static function getTempState(SigHashPreimage preimage): Object {
        bytes scriptCode = this.scriptCodeRaw(preimage);
		int scriptLen = len(scriptCode);
		return Aux.bytes_to_object(scriptCode[scriptLen-Aux.SizeOfObject:]);
	}
	//End get state
	//Set state
    static function setState(SigHashPreimage preimage, Object object): bool {
        bytes scriptCode = this.scriptCodeRaw(preimage);
		int scriptLen = len(scriptCode);
        bytes nextScript = scriptCode[:scriptLen-1-2*Aux.SizeOfObject] + Aux.object_to_bytes(object) + num2bin(0, 1) + scriptCode[scriptLen-Aux.SizeOfObject:];
        int nextValue = this.value(preimage) - Aux.fee;
        return (hash256(this.buildOutputRaw(nextScript, nextValue)) == this.hashOutputs(preimage));
    }
    static function setInLoop(SigHashPreimage preimage, int in_loop): bool {
        bytes scriptCode = this.scriptCodeRaw(preimage);
		int scriptLen = len(scriptCode);
        bytes nextScript = scriptCode[:scriptLen-1-Aux.SizeOfObject] + num2bin(in_loop, 1) + scriptCode[scriptLen-Aux.SizeOfObject:];
        int nextValue = this.value(preimage) - Aux.fee;
        return (hash256(this.buildOutputRaw(nextScript, nextValue)) == this.hashOutputs(preimage));
    }
    static function setTempState(SigHashPreimage preimage, Object object): bool {
        bytes scriptCode = this.scriptCodeRaw(preimage);
		int scriptLen = len(scriptCode);
        bytes nextScript = scriptCode[:scriptLen-Aux.SizeOfObject] + Aux.object_to_bytes(object);
        int nextValue = this.value(preimage) - Aux.fee;
        return (hash256(this.buildOutputRaw(nextScript, nextValue)) == this.hashOutputs(preimage));
    }
	//End set state
	//Functions to loop
    static function synchronised(SigHashPreimage preimage): bool {
        return this.getState(preimage) == this.getTempState(preimage);
    }
    static function to_loop_1(SigHashPreimage preimage): bool {
        bool valid = Tx.checkPreimage(preimage);
		valid = valid && (this.getInLoop(preimage) == 0);
        valid = valid && this.synchronised(preimage);
        valid = valid && this.setInLoop(preimage, 1);
        return valid;
    }
    static function to_loop_2(SigHashPreimage preimage): bool {
        bool valid = Tx.checkPreimage(preimage);
        valid = valid && (this.getInLoop(preimage) == 1);
        Object object = this.getTempState(preimage);
        DoNotTouch computation = Aux.my_great_function(object);
        if (computation.recursion) {
        	valid = valid && this.setTempState(preimage, computation.computation);
        }
        else {
            valid = valid && this.setInLoop(preimage, 2);
        }
        return valid;
    }
    static function recursive(SigHashPreimage preimage, Object object): Object {
		require(this.getState(preimage) == object);
        require(this.getInLoop(preimage) == 2);
        return this.getTempState(preimage);
    }
}