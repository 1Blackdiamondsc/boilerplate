import "util.scrypt";
import "merklepath.scrypt";


struct BlockHeader {
    bytes version;
    Sha256 prevBlockHash;
    Sha256 merkleRoot;
    bytes time;
    // difficulty target
    bytes bits;
    bytes nonce;
}


// a library to trustlessly access the blockchain: including blockheaders and transactions
library Blockchain {
    // block height's position relative to the beginning of coinbase tx
    // TODO: This assumes unlocking script can be pushed using OP_PUSH_1. See if it always holds?
    static const int BLOCK_HEIGHT_POS = 42;
    static const int DEPTH = 2;
    // SPV: is a txid in a block
    static function txInBlock(Sha256 txid, BlockHeader bh, MerklePaths merklePath) : bool {
        return MerklePath.calMerkleRoot(txid, merklePath) == bh.merkleRoot;
    }

    // is txid the last transaction in a block
    static function lastTxInBlock(Sha256 txid, BlockHeader bh, MerklePaths merklePath) : bool {
        bool last = true;
        Sha256 root = txid;

        loop (DEPTH) : i {
            Sibling s = merklePath[i];

            if(s.left > 0) { // s is valid
                // if node on the merkle path is on the right, it must be a duplicate
                // if node on the merkle path is on the left, it must NOT be a duplicate
                if (s.left != 1 && s.hash != root || s.left == 1 && s.hash == root) {
                    last = false;
                }
            }

            root = s.left == 1 ? hash256(s.hash + root) : hash256(root + s.hash);
        }

        return last && root == bh.merkleRoot;
    }

    // calculate a tx's index in a block from its merkle path
    // goes from top to bottom, the path basically encodes the index in binary form
    // left/L means 1, and right/R 0: e.g., (L, R, L) denotes 101 in binary, and 5 in decimal
    static function txIndex(MerklePaths merklePath) : int {
        int sum = 0;

        // traverse the path from top to bottom
        loop (DEPTH) : i {
            Sibling s = merklePath[DEPTH - i - 1];

            if(s.left > 0 ) {
                sum *= 2;
                if (s.left == 1) {
                    sum++;
                }
            }
        }
        return sum;
    }

    // get number of transactions in a block
    static function blockTxCount(BlockHeader bh, Sha256 lastTxid, MerklePaths merklePath) : int {
        // ensure this tx is indeed the last one
        require(lastTxInBlock(lastTxid, bh, merklePath));

        return txIndex(merklePath) + 1;
    }

    // is block header valid with difficulty meeting target
    static function isBlockHeaderValid(BlockHeader bh, int blockchainTarget) : bool {
        int bhHash = blockHeaderHashAsInt(bh);
        int target = bits2Target(bh.bits);
        bytes hash = blockHeaderHash(bh);
        // block hash below target and target below blockchain difficulty target
        return bhHash <= target && target <= blockchainTarget;
    }

    // is a chain of block headers valid
    static function isBlockHeaderChainValid(static const int N, BlockHeader[N] headers, int blockchainTarget) : bool {
        bool res = true;

        loop (N) : i {
            if (res) {
                // each block is valid
                if (!isBlockHeaderValid(headers[i], blockchainTarget))
                    res = false;

                if (i > 0) {
                    Sha256 prevBlockHash = blockHeaderHash(headers[i - 1]);
                    // blocks are chained
                    if (prevBlockHash != headers[i].prevBlockHash)
                        res = false; 
                }
            }
        }

        return res;
    }

    // 01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff1d0352e40a2f7376706f6f6c2e636f6d2f306c92f79739e3174831970000ffffffff01836e4125000000001976a91468888423f412b6b4166d61fe9e66a1aeff30df1f88ac00000000
    // is raw transaction a coinbase tx
    static function isCoinbase(bytes tx) : bool {
        return tx[4:5] == b'01' // only 1 input
            && tx[5:37] == b'0000000000000000000000000000000000000000000000000000000000000000' // null txid: all zeros
            && tx[37:41] == b'FFFFFFFF';    // null vout: all Fs
    }

    // a coinbase tx is the 1st tx in a block; thus all siblings on the merkle path must be on the right
    static function isCoinbase2(MerklePaths merklePath) : bool { 
        return MerklePath.isCoinbase(merklePath);
    }

    // get height of the block identified by the header
    static function blockHeight(BlockHeader bh, bytes coinbaseTx, MerklePaths merklePath) : int {
        
        // ensure coinbase it's in the block
        require(txInBlock(hash256(coinbaseTx), bh, merklePath));

        // ensure it's coinbase
        require(isCoinbase(coinbaseTx));
        // alternative
        // require(isCoinbase2(merklePath));

        return readBlockHeight(coinbaseTx);
    }

    // parse block height from coinbase tx: BIP34
    static function readBlockHeight(bytes coinbaseTx) : int {
        // block height is at the beginning of the unlocking script and encoded in varint
        return Util.fromLEUnsigned(Util.readVarint(coinbaseTx[BLOCK_HEIGHT_POS:]));
    }

    // convert difficulty from bits to target
    static function bits2Target(bytes bits) : int {
        int exponent = Util.fromLEUnsigned(bits[3 :]);
        int coefficient = Util.fromLEUnsigned(bits[: 3]);
        int n = 8 * (exponent - 3);
        bytes target = num2bin(coefficient, 32) >> n;
        return  Util.fromLEUnsigned(target);
    }

    // serialize a block header
    static function serialize(BlockHeader bh) : bytes {
        return bh.version + bh.prevBlockHash + bh.merkleRoot + bh.time + bh.bits + bh.nonce;
    }

    // block header hash
    static function blockHeaderHash(BlockHeader bh) : Sha256 {
        return hash256(serialize(bh));
    }

    // block header hash, but converted to a number
    static function blockHeaderHashAsInt(BlockHeader bh) : int {
        // hash is reversed
        // no need to change to unsigned here since it is already positive, due to leading zeros
        return Util.fromLEUnsigned(blockHeaderHash(bh));
    }
}