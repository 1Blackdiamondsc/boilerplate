import "Util.scrypt";
import "mast.scrypt";

struct BlockHeader {
    bytes version;
    Sha256 prevBlockHash;
    Sha256 merkleRoot;
    int time;
    // difficulty target
    bytes bits;
    bytes nonce;
}

// a library to trustlessly access the blockchain: including blockheaders and transactions
library Blockchain {
    // block height's position relative to the beginning of coinbase tx
    // TODO: This assumes unlocking script can be pushed using OP_PUSH_1. See if it always holds?
    static const int BLOCK_HEIGHT_POS = 42;

    // SPV: is a txid in a block
    static function txInBlock(Sha256 txid, BlockHeader bh, MerklePath merklePath) : bool {
        return MAST.calMerkleRoot(txid, merklePath) == bh.merkleRoot;
    }

    // is txid the last transaction in a block
    static function lastTxInBlock(Sha256 txid, BlockHeader bh, MerklePath merklePath) : bool {
        bool last = true;
        Sha256 root = txid;

        loop (MAST.DEPTH) : i {
            Sibling s = merklePath[i];

            // if node on the merkle path is on the right, it must be a duplicate
            if (!s.left) {
                if (s.hash != root) {
                    last = false;
                }
            }

            root = s.left ? hash256(s.hash + root) : hash256(root + s.hash);
        }

        return last && root == bh.merkleRoot;
    }

    // calculate a tx's index in a block from its merkle path
    // goes from top to bottom, the path basically encodes the index in binary form
    // left/L means 1, and right/R 0: e.g., (L, R, L) denotes 101 in binary, and 5 in decimal
    static function txIndex(MerklePath merklePath) : int {
        int sum = 0;

        // traverse the path from top to bottom
        loop (MAST.DEPTH) : i {
            Sibling s = merklePath[MAST.DEPTH - i - 1];

            sum *= 2;
            if (s.left) {
                sum++;
            }
        }
        return sum;
    }

    // get number of transactions in a block
    static function blockTxCount(BlockHeader bh, Sha256 lastTxid, MerklePath merklePath) : int {
        // ensure this tx is indeed the last one
        require(lastTxInBlock(lastTxid, bh, merklePath));

        return txIndex(merklePath) + 1;
    }

    // is block header valid with difficulty meeting target
    static function isBlockHeaderValid(BlockHeader bh, int blockchainTarget) : bool {
        int bhHash = blockHeaderHashAsInt(bh);
        int target = bits2Target(bh.bits);

        // block hash below target and target below blockchain difficulty target
        return bhHash <= target && target <= blockchainTarget;
    }

    // is a chain of block headers valid
    static function isBlockHeaderChainValid(static const int N, BlockHeader[N] headers, int blockchainTarget) : bool {
        bool res = true;

        loop (N) : i {
            if (res) {
                // each block is valid
                if (!isBlockHeaderValid(headers[i], blockchainTarget))
                    res = false;

                if (i > 0) {
                    Sha256 prevBlockHash = blockHeaderHash(headers[i - 1]);
                    // blocks are chained
                    if (prevBlockHash != headers[i].prevBlockHash)
                        res = false; 
                }
            }
        }

        return res;
    }

    // 01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff1d0352e40a2f7376706f6f6c2e636f6d2f306c92f79739e3174831970000ffffffff01836e4125000000001976a91468888423f412b6b4166d61fe9e66a1aeff30df1f88ac00000000
    // is raw transaction a coinbase tx
    static function isCoinbase(bytes tx) : bool {
        return tx[4:5] == b'01' // only 1 input
            && tx[5:37] == b'0000000000000000000000000000000000000000000000000000000000000000' // null txid: all zeros
            && tx[37:41] == b'FFFFFFFF';    // null vout: all Fs
    }

    // a coinbase tx is the 1st tx in a block; thus all siblings on the merkle path must be on the right
    static function isCoinbase2(MerklePath merklePath) : bool {
        bool res = true;

        loop (MAST.DEPTH) : i {
            // sibling on the right
            res = res && !merklePath[i].left;
        }
        return res;
    }

    // get height of the block identified by the header
    static function blockHeight(BlockHeader bh, bytes coinbaseTx, MerklePath merklePath, int blockchainTarget) : int {
        require(isBlockHeaderValid(bh, blockchainTarget));
        
        // ensure coinbase it's in the block
        require(txInBlock(hash256(coinbaseTx), bh, merklePath));

        // ensure it's coinbase
        require(isCoinbase(coinbaseTx));
        // alternative
        // require(isCoinbase2(merklePath));

        return readBlockHeight(coinbaseTx);
    }

    // parse block height from coinbase tx: BIP34
    static function readBlockHeight(bytes coinbaseTx) : int {
        // block height is at the beginning of the unlocking script and encoded in varint
        return unpack(Util.readVarint(coinbaseTx[BLOCK_HEIGHT_POS:]));
    }

    // convert difficulty from bits to target
    static function bits2Target(bytes bits) : int {
        int exponent = unpack(bits[3 :]);
        bytes coefficient = bits[: 3];
        int leadingZeroBytes = exponent - 3;

        bytes targetBytes = num2bin(0, leadingZeroBytes) + coefficient;
        return Util.fromLEUnsigned(targetBytes);
    }

    // serialize a block header
    static function serialize(BlockHeader bh) : bytes {
        return bh.version + bh.prevBlockHash + bh.merkleRoot + num2bin(bh.time, 4) + bh.bits + bh.nonce;
    }

    // block header hash
    static function blockHeaderHash(BlockHeader bh) : Sha256 {
        return hash256(serialize(bh));
    }

    // block header hash, but converted to a number
    static function blockHeaderHashAsInt(BlockHeader bh) : int {
        // hash is reversed
        // no need to change to unsigned here since it is already positive, due to leading zeros
        return unpack(reverseBytes(blockHeaderHash(bh), 32));
    }
}